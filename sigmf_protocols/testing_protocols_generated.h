// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TESTINGPROTOCOLS_H_
#define FLATBUFFERS_GENERATED_TESTINGPROTOCOLS_H_

#include "flatbuffers/flatbuffers.h"

struct testing_vecs;
struct testing_vecsBuilder;
struct testing_vecsT;

struct one;
struct oneBuilder;
struct oneT;

struct two;
struct twoBuilder;
struct twoT;

struct three;
struct threeBuilder;
struct threeT;

struct very_nested_thing;
struct very_nested_thingBuilder;
struct very_nested_thingT;

struct composed_type;
struct composed_typeBuilder;
struct composed_typeT;

struct testingunions;
struct testingunionsBuilder;
struct testingunionsT;

inline const flatbuffers::TypeTable *testing_vecsTypeTable();

inline const flatbuffers::TypeTable *oneTypeTable();

inline const flatbuffers::TypeTable *twoTypeTable();

inline const flatbuffers::TypeTable *threeTypeTable();

inline const flatbuffers::TypeTable *very_nested_thingTypeTable();

inline const flatbuffers::TypeTable *composed_typeTypeTable();

inline const flatbuffers::TypeTable *testingunionsTypeTable();

enum myunion : uint8_t {
  myunion_NONE = 0,
  myunion_one = 1,
  myunion_two = 2,
  myunion_three = 3,
  myunion_MIN = myunion_NONE,
  myunion_MAX = myunion_three
};

inline const myunion (&EnumValuesmyunion())[4] {
  static const myunion values[] = {
    myunion_NONE,
    myunion_one,
    myunion_two,
    myunion_three
  };
  return values;
}

inline const char * const *EnumNamesmyunion() {
  static const char * const names[5] = {
    "NONE",
    "one",
    "two",
    "three",
    nullptr
  };
  return names;
}

inline const char *EnumNamemyunion(myunion e) {
  if (flatbuffers::IsOutRange(e, myunion_NONE, myunion_three)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmyunion()[index];
}

template<typename T> struct myunionTraits {
  static const myunion enum_value = myunion_NONE;
};

template<> struct myunionTraits<one> {
  static const myunion enum_value = myunion_one;
};

template<> struct myunionTraits<two> {
  static const myunion enum_value = myunion_two;
};

template<> struct myunionTraits<three> {
  static const myunion enum_value = myunion_three;
};

struct myunionUnion {
  myunion type;
  void *value;

  myunionUnion() : type(myunion_NONE), value(nullptr) {}
  myunionUnion(myunionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(myunion_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  myunionUnion(const myunionUnion &);
  myunionUnion &operator=(const myunionUnion &u)
    { myunionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  myunionUnion &operator=(myunionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~myunionUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = myunionTraits<typename RT::TableType>::enum_value;
    if (type != myunion_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, myunion type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  oneT *Asone() {
    return type == myunion_one ?
      reinterpret_cast<oneT *>(value) : nullptr;
  }
  const oneT *Asone() const {
    return type == myunion_one ?
      reinterpret_cast<const oneT *>(value) : nullptr;
  }
  twoT *Astwo() {
    return type == myunion_two ?
      reinterpret_cast<twoT *>(value) : nullptr;
  }
  const twoT *Astwo() const {
    return type == myunion_two ?
      reinterpret_cast<const twoT *>(value) : nullptr;
  }
  threeT *Asthree() {
    return type == myunion_three ?
      reinterpret_cast<threeT *>(value) : nullptr;
  }
  const threeT *Asthree() const {
    return type == myunion_three ?
      reinterpret_cast<const threeT *>(value) : nullptr;
  }
};

bool Verifymyunion(flatbuffers::Verifier &verifier, const void *obj, myunion type);
bool VerifymyunionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct testing_vecsT : public flatbuffers::NativeTable {
  typedef testing_vecs TableType;
  std::vector<uint32_t> myvecfortesting{};
  std::string name{};
};

struct testing_vecs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef testing_vecsT NativeTableType;
  typedef testing_vecsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return testing_vecsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MYVECFORTESTING = 4,
    VT_NAME = 6
  };
  const flatbuffers::Vector<uint32_t> *myvecfortesting() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MYVECFORTESTING);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MYVECFORTESTING) &&
           verifier.VerifyVector(myvecfortesting()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  testing_vecsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(testing_vecsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<testing_vecs> Pack(flatbuffers::FlatBufferBuilder &_fbb, const testing_vecsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct testing_vecsBuilder {
  typedef testing_vecs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_myvecfortesting(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> myvecfortesting) {
    fbb_.AddOffset(testing_vecs::VT_MYVECFORTESTING, myvecfortesting);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(testing_vecs::VT_NAME, name);
  }
  explicit testing_vecsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<testing_vecs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<testing_vecs>(end);
    return o;
  }
};

inline flatbuffers::Offset<testing_vecs> Createtesting_vecs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> myvecfortesting = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  testing_vecsBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_myvecfortesting(myvecfortesting);
  return builder_.Finish();
}

inline flatbuffers::Offset<testing_vecs> Createtesting_vecsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *myvecfortesting = nullptr,
    const char *name = nullptr) {
  auto myvecfortesting__ = myvecfortesting ? _fbb.CreateVector<uint32_t>(*myvecfortesting) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Createtesting_vecs(
      _fbb,
      myvecfortesting__,
      name__);
}

flatbuffers::Offset<testing_vecs> Createtesting_vecs(flatbuffers::FlatBufferBuilder &_fbb, const testing_vecsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct oneT : public flatbuffers::NativeTable {
  typedef one TableType;
  float fieldone = 0.0f;
};

struct one FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef oneT NativeTableType;
  typedef oneBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return oneTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDONE = 4
  };
  float fieldone() const {
    return GetField<float>(VT_FIELDONE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FIELDONE) &&
           verifier.EndTable();
  }
  oneT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(oneT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<one> Pack(flatbuffers::FlatBufferBuilder &_fbb, const oneT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct oneBuilder {
  typedef one Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fieldone(float fieldone) {
    fbb_.AddElement<float>(one::VT_FIELDONE, fieldone, 0.0f);
  }
  explicit oneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<one> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<one>(end);
    return o;
  }
};

inline flatbuffers::Offset<one> Createone(
    flatbuffers::FlatBufferBuilder &_fbb,
    float fieldone = 0.0f) {
  oneBuilder builder_(_fbb);
  builder_.add_fieldone(fieldone);
  return builder_.Finish();
}

flatbuffers::Offset<one> Createone(flatbuffers::FlatBufferBuilder &_fbb, const oneT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct twoT : public flatbuffers::NativeTable {
  typedef two TableType;
  float fieldtwo = 0.0f;
};

struct two FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef twoT NativeTableType;
  typedef twoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return twoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDTWO = 4
  };
  float fieldtwo() const {
    return GetField<float>(VT_FIELDTWO, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FIELDTWO) &&
           verifier.EndTable();
  }
  twoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(twoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<two> Pack(flatbuffers::FlatBufferBuilder &_fbb, const twoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct twoBuilder {
  typedef two Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fieldtwo(float fieldtwo) {
    fbb_.AddElement<float>(two::VT_FIELDTWO, fieldtwo, 0.0f);
  }
  explicit twoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<two> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<two>(end);
    return o;
  }
};

inline flatbuffers::Offset<two> Createtwo(
    flatbuffers::FlatBufferBuilder &_fbb,
    float fieldtwo = 0.0f) {
  twoBuilder builder_(_fbb);
  builder_.add_fieldtwo(fieldtwo);
  return builder_.Finish();
}

flatbuffers::Offset<two> Createtwo(flatbuffers::FlatBufferBuilder &_fbb, const twoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct threeT : public flatbuffers::NativeTable {
  typedef three TableType;
  float fieldthree = 0.0f;
};

struct three FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef threeT NativeTableType;
  typedef threeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return threeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDTHREE = 4
  };
  float fieldthree() const {
    return GetField<float>(VT_FIELDTHREE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FIELDTHREE) &&
           verifier.EndTable();
  }
  threeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(threeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<three> Pack(flatbuffers::FlatBufferBuilder &_fbb, const threeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct threeBuilder {
  typedef three Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fieldthree(float fieldthree) {
    fbb_.AddElement<float>(three::VT_FIELDTHREE, fieldthree, 0.0f);
  }
  explicit threeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<three> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<three>(end);
    return o;
  }
};

inline flatbuffers::Offset<three> Createthree(
    flatbuffers::FlatBufferBuilder &_fbb,
    float fieldthree = 0.0f) {
  threeBuilder builder_(_fbb);
  builder_.add_fieldthree(fieldthree);
  return builder_.Finish();
}

flatbuffers::Offset<three> Createthree(flatbuffers::FlatBufferBuilder &_fbb, const threeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct very_nested_thingT : public flatbuffers::NativeTable {
  typedef very_nested_thing TableType;
  uint64_t wow = 0;
};

struct very_nested_thing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef very_nested_thingT NativeTableType;
  typedef very_nested_thingBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return very_nested_thingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WOW = 4
  };
  uint64_t wow() const {
    return GetField<uint64_t>(VT_WOW, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_WOW) &&
           verifier.EndTable();
  }
  very_nested_thingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(very_nested_thingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<very_nested_thing> Pack(flatbuffers::FlatBufferBuilder &_fbb, const very_nested_thingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct very_nested_thingBuilder {
  typedef very_nested_thing Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wow(uint64_t wow) {
    fbb_.AddElement<uint64_t>(very_nested_thing::VT_WOW, wow, 0);
  }
  explicit very_nested_thingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<very_nested_thing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<very_nested_thing>(end);
    return o;
  }
};

inline flatbuffers::Offset<very_nested_thing> Createvery_nested_thing(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t wow = 0) {
  very_nested_thingBuilder builder_(_fbb);
  builder_.add_wow(wow);
  return builder_.Finish();
}

flatbuffers::Offset<very_nested_thing> Createvery_nested_thing(flatbuffers::FlatBufferBuilder &_fbb, const very_nested_thingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct composed_typeT : public flatbuffers::NativeTable {
  typedef composed_type TableType;
  std::string name{};
  std::vector<std::string> comments{};
  int32_t index = 0;
  std::vector<std::shared_ptr<very_nested_thingT>> nnnnnn{};
};

struct composed_type FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef composed_typeT NativeTableType;
  typedef composed_typeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return composed_typeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_COMMENTS = 6,
    VT_INDEX = 8,
    VT_NNNNNN = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *comments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COMMENTS);
  }
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<very_nested_thing>> *nnnnnn() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<very_nested_thing>> *>(VT_NNNNNN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_COMMENTS) &&
           verifier.VerifyVector(comments()) &&
           verifier.VerifyVectorOfStrings(comments()) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_NNNNNN) &&
           verifier.VerifyVector(nnnnnn()) &&
           verifier.VerifyVectorOfTables(nnnnnn()) &&
           verifier.EndTable();
  }
  composed_typeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(composed_typeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<composed_type> Pack(flatbuffers::FlatBufferBuilder &_fbb, const composed_typeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct composed_typeBuilder {
  typedef composed_type Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(composed_type::VT_NAME, name);
  }
  void add_comments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> comments) {
    fbb_.AddOffset(composed_type::VT_COMMENTS, comments);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(composed_type::VT_INDEX, index, 0);
  }
  void add_nnnnnn(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<very_nested_thing>>> nnnnnn) {
    fbb_.AddOffset(composed_type::VT_NNNNNN, nnnnnn);
  }
  explicit composed_typeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<composed_type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<composed_type>(end);
    return o;
  }
};

inline flatbuffers::Offset<composed_type> Createcomposed_type(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> comments = 0,
    int32_t index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<very_nested_thing>>> nnnnnn = 0) {
  composed_typeBuilder builder_(_fbb);
  builder_.add_nnnnnn(nnnnnn);
  builder_.add_index(index);
  builder_.add_comments(comments);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<composed_type> Createcomposed_typeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *comments = nullptr,
    int32_t index = 0,
    const std::vector<flatbuffers::Offset<very_nested_thing>> *nnnnnn = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto comments__ = comments ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*comments) : 0;
  auto nnnnnn__ = nnnnnn ? _fbb.CreateVector<flatbuffers::Offset<very_nested_thing>>(*nnnnnn) : 0;
  return Createcomposed_type(
      _fbb,
      name__,
      comments__,
      index,
      nnnnnn__);
}

flatbuffers::Offset<composed_type> Createcomposed_type(flatbuffers::FlatBufferBuilder &_fbb, const composed_typeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct testingunionsT : public flatbuffers::NativeTable {
  typedef testingunions TableType;
  myunionUnion myfield{};
  int32_t dumbfield = 0;
};

struct testingunions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef testingunionsT NativeTableType;
  typedef testingunionsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return testingunionsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MYFIELD_TYPE = 4,
    VT_MYFIELD = 6,
    VT_DUMBFIELD = 8
  };
  myunion myfield_type() const {
    return static_cast<myunion>(GetField<uint8_t>(VT_MYFIELD_TYPE, 0));
  }
  const void *myfield() const {
    return GetPointer<const void *>(VT_MYFIELD);
  }
  template<typename T> const T *myfield_as() const;
  const one *myfield_as_one() const {
    return myfield_type() == myunion_one ? static_cast<const one *>(myfield()) : nullptr;
  }
  const two *myfield_as_two() const {
    return myfield_type() == myunion_two ? static_cast<const two *>(myfield()) : nullptr;
  }
  const three *myfield_as_three() const {
    return myfield_type() == myunion_three ? static_cast<const three *>(myfield()) : nullptr;
  }
  int32_t dumbfield() const {
    return GetField<int32_t>(VT_DUMBFIELD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MYFIELD_TYPE) &&
           VerifyOffset(verifier, VT_MYFIELD) &&
           Verifymyunion(verifier, myfield(), myfield_type()) &&
           VerifyField<int32_t>(verifier, VT_DUMBFIELD) &&
           verifier.EndTable();
  }
  testingunionsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(testingunionsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<testingunions> Pack(flatbuffers::FlatBufferBuilder &_fbb, const testingunionsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const one *testingunions::myfield_as<one>() const {
  return myfield_as_one();
}

template<> inline const two *testingunions::myfield_as<two>() const {
  return myfield_as_two();
}

template<> inline const three *testingunions::myfield_as<three>() const {
  return myfield_as_three();
}

struct testingunionsBuilder {
  typedef testingunions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_myfield_type(myunion myfield_type) {
    fbb_.AddElement<uint8_t>(testingunions::VT_MYFIELD_TYPE, static_cast<uint8_t>(myfield_type), 0);
  }
  void add_myfield(flatbuffers::Offset<void> myfield) {
    fbb_.AddOffset(testingunions::VT_MYFIELD, myfield);
  }
  void add_dumbfield(int32_t dumbfield) {
    fbb_.AddElement<int32_t>(testingunions::VT_DUMBFIELD, dumbfield, 0);
  }
  explicit testingunionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<testingunions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<testingunions>(end);
    return o;
  }
};

inline flatbuffers::Offset<testingunions> Createtestingunions(
    flatbuffers::FlatBufferBuilder &_fbb,
    myunion myfield_type = myunion_NONE,
    flatbuffers::Offset<void> myfield = 0,
    int32_t dumbfield = 0) {
  testingunionsBuilder builder_(_fbb);
  builder_.add_dumbfield(dumbfield);
  builder_.add_myfield(myfield);
  builder_.add_myfield_type(myfield_type);
  return builder_.Finish();
}

flatbuffers::Offset<testingunions> Createtestingunions(flatbuffers::FlatBufferBuilder &_fbb, const testingunionsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline testing_vecsT *testing_vecs::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<testing_vecsT>(new testing_vecsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void testing_vecs::UnPackTo(testing_vecsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = myvecfortesting(); if (_e) { _o->myvecfortesting.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->myvecfortesting[_i] = _e->Get(_i); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<testing_vecs> testing_vecs::Pack(flatbuffers::FlatBufferBuilder &_fbb, const testing_vecsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createtesting_vecs(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<testing_vecs> Createtesting_vecs(flatbuffers::FlatBufferBuilder &_fbb, const testing_vecsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const testing_vecsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _myvecfortesting = _o->myvecfortesting.size() ? _fbb.CreateVector(_o->myvecfortesting) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return Createtesting_vecs(
      _fbb,
      _myvecfortesting,
      _name);
}

inline oneT *one::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<oneT>(new oneT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void one::UnPackTo(oneT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fieldone(); _o->fieldone = _e; }
}

inline flatbuffers::Offset<one> one::Pack(flatbuffers::FlatBufferBuilder &_fbb, const oneT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createone(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<one> Createone(flatbuffers::FlatBufferBuilder &_fbb, const oneT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const oneT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fieldone = _o->fieldone;
  return Createone(
      _fbb,
      _fieldone);
}

inline twoT *two::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<twoT>(new twoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void two::UnPackTo(twoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fieldtwo(); _o->fieldtwo = _e; }
}

inline flatbuffers::Offset<two> two::Pack(flatbuffers::FlatBufferBuilder &_fbb, const twoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createtwo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<two> Createtwo(flatbuffers::FlatBufferBuilder &_fbb, const twoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const twoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fieldtwo = _o->fieldtwo;
  return Createtwo(
      _fbb,
      _fieldtwo);
}

inline threeT *three::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<threeT>(new threeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void three::UnPackTo(threeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fieldthree(); _o->fieldthree = _e; }
}

inline flatbuffers::Offset<three> three::Pack(flatbuffers::FlatBufferBuilder &_fbb, const threeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createthree(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<three> Createthree(flatbuffers::FlatBufferBuilder &_fbb, const threeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const threeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fieldthree = _o->fieldthree;
  return Createthree(
      _fbb,
      _fieldthree);
}

inline very_nested_thingT *very_nested_thing::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<very_nested_thingT>(new very_nested_thingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void very_nested_thing::UnPackTo(very_nested_thingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = wow(); _o->wow = _e; }
}

inline flatbuffers::Offset<very_nested_thing> very_nested_thing::Pack(flatbuffers::FlatBufferBuilder &_fbb, const very_nested_thingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createvery_nested_thing(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<very_nested_thing> Createvery_nested_thing(flatbuffers::FlatBufferBuilder &_fbb, const very_nested_thingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const very_nested_thingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _wow = _o->wow;
  return Createvery_nested_thing(
      _fbb,
      _wow);
}

inline composed_typeT *composed_type::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<composed_typeT>(new composed_typeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void composed_type::UnPackTo(composed_typeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = comments(); if (_e) { _o->comments.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->comments[_i] = _e->Get(_i)->str(); } } }
  { auto _e = index(); _o->index = _e; }
  { auto _e = nnnnnn(); if (_e) { _o->nnnnnn.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->nnnnnn[_i] = std::shared_ptr<very_nested_thingT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<composed_type> composed_type::Pack(flatbuffers::FlatBufferBuilder &_fbb, const composed_typeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createcomposed_type(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<composed_type> Createcomposed_type(flatbuffers::FlatBufferBuilder &_fbb, const composed_typeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const composed_typeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _comments = _o->comments.size() ? _fbb.CreateVectorOfStrings(_o->comments) : 0;
  auto _index = _o->index;
  auto _nnnnnn = _o->nnnnnn.size() ? _fbb.CreateVector<flatbuffers::Offset<very_nested_thing>> (_o->nnnnnn.size(), [](size_t i, _VectorArgs *__va) { return Createvery_nested_thing(*__va->__fbb, __va->__o->nnnnnn[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Createcomposed_type(
      _fbb,
      _name,
      _comments,
      _index,
      _nnnnnn);
}

inline testingunionsT *testingunions::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<testingunionsT>(new testingunionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void testingunions::UnPackTo(testingunionsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = myfield_type(); _o->myfield.type = _e; }
  { auto _e = myfield(); if (_e) _o->myfield.value = myunionUnion::UnPack(_e, myfield_type(), _resolver); }
  { auto _e = dumbfield(); _o->dumbfield = _e; }
}

inline flatbuffers::Offset<testingunions> testingunions::Pack(flatbuffers::FlatBufferBuilder &_fbb, const testingunionsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return Createtestingunions(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<testingunions> Createtestingunions(flatbuffers::FlatBufferBuilder &_fbb, const testingunionsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const testingunionsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _myfield_type = _o->myfield.type;
  auto _myfield = _o->myfield.Pack(_fbb);
  auto _dumbfield = _o->dumbfield;
  return Createtestingunions(
      _fbb,
      _myfield_type,
      _myfield,
      _dumbfield);
}

inline bool Verifymyunion(flatbuffers::Verifier &verifier, const void *obj, myunion type) {
  switch (type) {
    case myunion_NONE: {
      return true;
    }
    case myunion_one: {
      auto ptr = reinterpret_cast<const one *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case myunion_two: {
      auto ptr = reinterpret_cast<const two *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case myunion_three: {
      auto ptr = reinterpret_cast<const three *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifymyunionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifymyunion(
        verifier,  values->Get(i), types->GetEnum<myunion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *myunionUnion::UnPack(const void *obj, myunion type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case myunion_one: {
      auto ptr = reinterpret_cast<const one *>(obj);
      return ptr->UnPack(resolver);
    }
    case myunion_two: {
      auto ptr = reinterpret_cast<const two *>(obj);
      return ptr->UnPack(resolver);
    }
    case myunion_three: {
      auto ptr = reinterpret_cast<const three *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> myunionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case myunion_one: {
      auto ptr = reinterpret_cast<const oneT *>(value);
      return Createone(_fbb, ptr, _rehasher).Union();
    }
    case myunion_two: {
      auto ptr = reinterpret_cast<const twoT *>(value);
      return Createtwo(_fbb, ptr, _rehasher).Union();
    }
    case myunion_three: {
      auto ptr = reinterpret_cast<const threeT *>(value);
      return Createthree(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline myunionUnion::myunionUnion(const myunionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case myunion_one: {
      value = new oneT(*reinterpret_cast<oneT *>(u.value));
      break;
    }
    case myunion_two: {
      value = new twoT(*reinterpret_cast<twoT *>(u.value));
      break;
    }
    case myunion_three: {
      value = new threeT(*reinterpret_cast<threeT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void myunionUnion::Reset() {
  switch (type) {
    case myunion_one: {
      auto ptr = reinterpret_cast<oneT *>(value);
      delete ptr;
      break;
    }
    case myunion_two: {
      auto ptr = reinterpret_cast<twoT *>(value);
      delete ptr;
      break;
    }
    case myunion_three: {
      auto ptr = reinterpret_cast<threeT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = myunion_NONE;
}

inline const flatbuffers::TypeTable *myunionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    oneTypeTable,
    twoTypeTable,
    threeTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "one",
    "two",
    "three"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *testing_vecsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 1, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "myvecfortesting",
    "name"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *oneTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "fieldone"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *twoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "fieldtwo"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *threeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "fieldthree"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *very_nested_thingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "wow"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *composed_typeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    very_nested_thingTypeTable
  };
  static const char * const names[] = {
    "name",
    "comments",
    "index",
    "nnnnnn"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *testingunionsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    myunionTypeTable
  };
  static const char * const names[] = {
    "myfield_type",
    "myfield",
    "dumbfield"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

#endif  // FLATBUFFERS_GENERATED_TESTINGPROTOCOLS_H_
